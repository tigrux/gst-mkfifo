/* callbacks.c generated by valac 0.10.0, the Vala compiler
 * generated from callbacks.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gst/gst.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

typedef void (*CommandFunction) (const char* line);

extern GHashTable* commands_table;
extern GstElement* pipeline;

gboolean on_channel (GIOChannel* channel, GIOCondition condition);
char* partition (const char* line, char** head);
void exec_command (const char* command_name, const char* line);
gboolean init_channel (void);
void on_bus_message_eos (void);
void on_bus_message_error (GstBus* bus, GstMessage* message);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);



static char* string_strip (const char* self) {
	char* result = NULL;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strstrip (_result_);
	result = _result_;
	return result;
}


gboolean on_channel (GIOChannel* channel, GIOCondition condition) {
	gboolean result = FALSE;
	char* command_name;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (channel != NULL, FALSE);
	g_return_val_if_fail (commands_table != NULL, FALSE);
	command_name = NULL;
	if ((condition & G_IO_IN) != 0) {
		char* line;
		line = NULL;
		{
			char* _tmp0_ = NULL;
			char* _tmp1_;
			g_io_channel_read_line (channel, &_tmp0_, NULL, NULL, &_inner_error_);
			line = (_tmp1_ = _tmp0_, _g_free0 (line), _tmp1_);
			if (_inner_error_ != NULL) {
				goto __catch0_g_error;
			}
		}
		goto __finally0;
		__catch0_g_error:
		{
			g_clear_error (&_inner_error_);
			_inner_error_ = NULL;
			{
				char* _tmp2_;
				g_printerr ("Could not read from channel\n");
				line = (_tmp2_ = NULL, _g_free0 (line), _tmp2_);
			}
		}
		__finally0:
		if (_inner_error_ != NULL) {
			_g_free0 (line);
			_g_free0 (command_name);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		if (line != NULL) {
			char* _tmp3_;
			char* _tmp4_ = NULL;
			char* _tmp5_;
			char* _tmp6_;
			char* _tmp7_;
			line = (_tmp3_ = string_strip (line), _g_free0 (line), _tmp3_);
			g_print ("Got line '%s'\n", line);
			line = (_tmp7_ = (_tmp5_ = partition (line, &_tmp4_), command_name = (_tmp6_ = _tmp4_, _g_free0 (command_name), _tmp6_), _tmp5_), _g_free0 (line), _tmp7_);
			if (command_name != NULL) {
				exec_command (command_name, line);
			}
		}
		_g_free0 (line);
	}
	if ((condition & G_IO_HUP) != 0) {
		if (!init_channel ()) {
			exec_command ("quit", NULL);
		}
		result = FALSE;
		_g_free0 (command_name);
		return result;
	}
	result = TRUE;
	_g_free0 (command_name);
	return result;
}


void on_bus_message_eos (void) {
	g_return_if_fail (pipeline != NULL);
	gst_element_set_state (pipeline, GST_STATE_NULL);
	exec_command ("exit", NULL);
}


void on_bus_message_error (GstBus* bus, GstMessage* message) {
	GError* _error_;
	char* debug;
	GError* _tmp0_ = NULL;
	GError* _tmp1_;
	char* _tmp2_ = NULL;
	char* _tmp3_;
	const char* _tmp4_;
	g_return_if_fail (bus != NULL);
	g_return_if_fail (message != NULL);
	_error_ = NULL;
	debug = NULL;
	(gst_message_parse_error (message, &_tmp0_, &_tmp2_), _error_ = (_tmp1_ = _tmp0_, _g_error_free0 (_error_), _tmp1_));
	debug = (_tmp3_ = _tmp2_, _g_free0 (debug), _tmp3_);
	g_printerr ("ERROR from element %s: %s\n", gst_object_get_name (message->src), _error_->message);
	_tmp4_ = NULL;
	if (debug != NULL) {
		_tmp4_ = debug;
	} else {
		_tmp4_ = "none";
	}
	g_printerr ("Debugging info: %s\n", _tmp4_);
	on_bus_message_eos ();
	_g_free0 (debug);
	_g_error_free0 (_error_);
}


char* partition (const char* line, char** head) {
	char* result = NULL;
	gint parts_length1;
	gint _parts_size_;
	char** _tmp1_;
	char** _tmp0_;
	char** parts;
	char* _tmp2_;
	g_return_val_if_fail (line != NULL, NULL);
	if (head != NULL) {
		*head = NULL;
	}
	parts = (_tmp1_ = _tmp0_ = g_strsplit (line, " ", 2), parts_length1 = _vala_array_length (_tmp0_), _parts_size_ = parts_length1, _tmp1_);
	*head = (_tmp2_ = g_strdup (parts[0]), _g_free0 (*head), _tmp2_);
	result = g_strdup (parts[1]);
	parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


void exec_command (const char* command_name, const char* line) {
	CommandFunction function;
	g_return_if_fail (command_name != NULL);
	function = g_hash_table_lookup (commands_table, command_name);
	if (function != NULL) {
		function (line);
	} else {
		g_printerr ("No function for command '%s'\n", command_name);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




