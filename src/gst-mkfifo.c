/* gst-mkfifo.c generated by valac 0.10.0, the Vala compiler
 * generated from gst-mkfifo.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gst/gst.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))

typedef void (*CommandFunction) (const char* line);

extern GstBin* pipeline;
GstBin* pipeline = NULL;
extern GMainLoop* loop;
GMainLoop* loop = NULL;
extern char* fifo_path;
char* fifo_path = NULL;
extern GHashTable* commands_table;
GHashTable* commands_table = NULL;
extern GIOChannel* channel;
GIOChannel* channel = NULL;

gboolean init_channel (void);
gboolean on_channel (GIOChannel* channel, GIOCondition condition);
static gboolean _on_channel_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
gint _vala_main (char** args, int args_length1);
void init_commands (void);
static void _lambda0_ (void* key);
static void __lambda0__gh_func (void* key, void* value, gpointer self);



static gboolean _on_channel_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = on_channel (source, condition);
	return result;
}


gboolean init_channel (void) {
	gboolean result = FALSE;
	gint fd;
	if (channel != NULL) {
		GIOChannel* _tmp0_;
		close (g_io_channel_unix_get_fd (channel));
		channel = (_tmp0_ = NULL, _g_io_channel_unref0 (channel), _tmp0_);
	}
	fd = open (fifo_path, O_NONBLOCK | O_RDONLY, 0);
	if (fd >= 0) {
		GIOChannel* _tmp1_;
		channel = (_tmp1_ = g_io_channel_unix_new (fd), _g_io_channel_unref0 (channel), _tmp1_);
		g_io_add_watch (channel, G_IO_IN | G_IO_HUP, _on_channel_gio_func, NULL);
		result = TRUE;
		return result;
	} else {
		g_print ("Could not open '%s' for reading\n", fifo_path);
		result = FALSE;
		return result;
	}
}


static void _lambda0_ (void* key) {
	g_print ("  %s\n", (const char*) key);
}


static void __lambda0__gh_func (void* key, void* value, gpointer self) {
	_lambda0_ (key);
}


gint _vala_main (char** args, int args_length1) {
	gint result = 0;
	char* _tmp0_;
	GMainLoop* _tmp1_;
	gst_init (&args_length1, &args);
	init_commands ();
	if (args_length1 != 2) {
		g_printerr ("Usage: %s <fifo>\n", args[0]);
		g_printerr ("Where <fifo> can be written the following commands:\n");
		g_hash_table_foreach (commands_table, __lambda0__gh_func, NULL);
		result = 1;
		return result;
	}
	fifo_path = (_tmp0_ = g_strdup (args[1]), _g_free0 (fifo_path), _tmp0_);
	if (mkfifo (fifo_path, (mode_t) 0666) != 0) {
		g_printerr ("Could not create the fifo '%s'\n", fifo_path);
		result = 1;
		return result;
	}
	if (!init_channel ()) {
		result = 1;
		return result;
	}
	loop = (_tmp1_ = g_main_loop_new (NULL, FALSE), _g_main_loop_unref0 (loop), _tmp1_);
	g_main_loop_run (loop);
	unlink (fifo_path);
	result = 0;
	return result;
}


int main (int argc, char ** argv) {
	g_thread_init (NULL);
	g_type_init ();
	return _vala_main (argv, argc);
}




