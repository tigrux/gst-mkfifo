/* commands.c generated by valac 0.10.0, the Vala compiler
 * generated from commands.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gst/gst.h>


#define TYPE_COMMAND (command_get_type ())
typedef struct _Command Command;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
#define _gst_event_unref0(var) ((var == NULL) ? NULL : (var = (gst_event_unref (var), NULL)))

typedef void (*CommandFunction) (const char* line);
struct _Command {
	char* name;
	CommandFunction function;
};


extern GstElement* pipeline;
extern GMainLoop* loop;

GType command_get_type (void) G_GNUC_CONST;
Command* command_dup (const Command* self);
void command_free (Command* self);
void command_copy (const Command* self, Command* dest);
void command_destroy (Command* self);
void command_parse (const char* line);
static void _command_parse_command_function (const char* line);
void command_play (const char* line);
static void _command_play_command_function (const char* line);
void command_pause (const char* line);
static void _command_pause_command_function (const char* line);
void command_ready (const char* line);
static void _command_ready_command_function (const char* line);
void command_null (const char* line);
static void _command_null_command_function (const char* line);
void command_seek (const char* line);
static void _command_seek_command_function (const char* line);
void command_eos (const char* line);
static void _command_eos_command_function (const char* line);
void command_exit (const char* line);
static void _command_exit_command_function (const char* line);
void on_bus_message_eos (void);
static void _on_bus_message_eos_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self);
void on_bus_message_error (GstBus* bus, GstMessage* message);
static void _on_bus_message_error_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self);

const Command commands[9] = {{"parse", _command_parse_command_function}, {"play", _command_play_command_function}, {"pause", _command_pause_command_function}, {"ready", _command_ready_command_function}, {"null", _command_null_command_function}, {"seek", _command_seek_command_function}, {"eos", _command_eos_command_function}, {"exit", _command_exit_command_function}, {NULL, NULL}};


void command_copy (const Command* self, Command* dest) {
	dest->name = g_strdup (self->name);
	dest->function = self->function;
}


void command_destroy (Command* self) {
	_g_free0 (self->name);
}


Command* command_dup (const Command* self) {
	Command* dup;
	dup = g_new0 (Command, 1);
	command_copy (self, dup);
	return dup;
}


void command_free (Command* self) {
	command_destroy (self);
	g_free (self);
}


GType command_get_type (void) {
	static volatile gsize command_type_id__volatile = 0;
	if (g_once_init_enter (&command_type_id__volatile)) {
		GType command_type_id;
		command_type_id = g_boxed_type_register_static ("Command", (GBoxedCopyFunc) command_dup, (GBoxedFreeFunc) command_free);
		g_once_init_leave (&command_type_id__volatile, command_type_id);
	}
	return command_type_id__volatile;
}


static void _command_parse_command_function (const char* line) {
	command_parse (line);
}


static void _command_play_command_function (const char* line) {
	command_play (line);
}


static void _command_pause_command_function (const char* line) {
	command_pause (line);
}


static void _command_ready_command_function (const char* line) {
	command_ready (line);
}


static void _command_null_command_function (const char* line) {
	command_null (line);
}


static void _command_seek_command_function (const char* line) {
	command_seek (line);
}


static void _command_eos_command_function (const char* line) {
	command_eos (line);
}


static void _command_exit_command_function (const char* line) {
	command_exit (line);
}


static void _on_bus_message_eos_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self) {
	on_bus_message_eos ();
}


static void _on_bus_message_error_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self) {
	on_bus_message_error (_sender, message);
}


void command_parse (const char* line) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (line != NULL);
	{
		GstElement* _tmp0_;
		GstElement* _tmp1_;
		_tmp0_ = gst_parse_launch (line, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		pipeline = (_tmp1_ = _tmp0_, _gst_object_unref0 (pipeline), _tmp1_);
	}
	goto __finally1;
	__catch1_g_error:
	{
		g_clear_error (&_inner_error_);
		_inner_error_ = NULL;
		{
			g_printerr ("Could not parse the pipeline '%s'\n", line);
		}
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	if (pipeline != NULL) {
		GstBus* bus;
		bus = gst_element_get_bus (pipeline);
		gst_bus_add_signal_watch (bus);
		g_signal_connect (bus, "message::eos", (GCallback) _on_bus_message_eos_gst_bus_message, NULL);
		g_signal_connect (bus, "message::error", (GCallback) _on_bus_message_error_gst_bus_message, NULL);
		_gst_object_unref0 (bus);
	}
}


void command_play (const char* line) {
	g_return_if_fail (pipeline != NULL);
	gst_element_set_state (pipeline, GST_STATE_PLAYING);
}


void command_pause (const char* line) {
	g_return_if_fail (pipeline != NULL);
	gst_element_set_state (pipeline, GST_STATE_PAUSED);
}


void command_ready (const char* line) {
	g_return_if_fail (pipeline != NULL);
	gst_element_set_state (pipeline, GST_STATE_READY);
}


void command_null (const char* line) {
	g_return_if_fail (pipeline != NULL);
	gst_element_set_state (pipeline, GST_STATE_NULL);
}


static gpointer _gst_event_ref0 (gpointer self) {
	return self ? gst_event_ref (self) : NULL;
}


void command_seek (const char* line) {
	gint direction = 0;
	gint64 useconds;
	gint64 position = 0LL;
	GstEvent* seek_event;
	g_return_if_fail (line != NULL);
	if (g_str_has_prefix (line, "+")) {
		direction = 1;
	} else {
		if (g_str_has_prefix (line, "-")) {
			direction = -1;
		} else {
			direction = 0;
		}
	}
	if (direction != 0) {
		line = g_utf8_next_char (line);
	}
	useconds = (gint64) (g_ascii_strtod (line, NULL) * GST_SECOND);
	if (direction != 0) {
		GstFormat time_format;
		time_format = GST_FORMAT_TIME;
		if (gst_element_query_position (pipeline, &time_format, &position)) {
			position = position + (useconds * direction);
		} else {
			g_printerr ("Could not get the current position\n");
			return;
		}
	} else {
		position = useconds;
	}
	seek_event = gst_event_new_seek (1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE, GST_SEEK_TYPE_SET, position, GST_SEEK_TYPE_NONE, (gint64) 0);
	gst_element_send_event (pipeline, _gst_event_ref0 (seek_event));
	_gst_event_unref0 (seek_event);
}


void command_eos (const char* line) {
	g_return_if_fail (pipeline != NULL);
	gst_element_send_event (pipeline, gst_event_new_eos ());
}


void command_exit (const char* line) {
	g_return_if_fail (loop != NULL);
	g_main_loop_quit (loop);
}




